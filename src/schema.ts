/* tslint:disable */


/**
 * AUTO-GENERATED FILE @ 2019-11-04 16:12:30 - DO NOT EDIT!
 *
 * This file was automatically generated by schemats v.3.0.3
 * $ schemats generate -c postgres://localhost/mostly_ormless -t appleTransactions -t authors -t books -t emailAuthentication -t tags -s public
 *
 */


import {
    DefaultType,
    JSONValue,
    JSONArray,
    SQLFragment,
    GenericSQLExpression,
    SQLExpression,
    AllType,
    ColumnNames,
    ColumnValues,
    Queryable,
    UpsertAction,
	PromisedType,
    SelectResultMode,
    SQLFragmentsMap,
    PromisedSQLFragmentReturnType,
    PromisedSQLFragmentReturnTypeMap,
} from "./core";

export type appleEnvironment = 'PROD' | 'Sandbox';
export namespace every {
    export type appleEnvironment = ['PROD', 'Sandbox'];
}

export namespace appleTransactions {
    export type Table = "appleTransactions";
    export interface Selectable {
        environment: appleEnvironment;
        originalTransactionId: string;
        accountId: number;
        latestReceiptData: string | null;
    }
    export interface Insertable {
        environment: appleEnvironment | SQLFragment;
        originalTransactionId: string | SQLFragment;
        accountId: number | SQLFragment;
        latestReceiptData?: string | null | DefaultType | SQLFragment;
    }
    export interface Updatable extends Partial<Insertable> { };
    export type Whereable = { [K in keyof Selectable]?: Selectable[K] | SQLFragment };
    export interface UpsertReturnable extends Selectable, UpsertAction { };
    export type Column = keyof Selectable;
    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
    export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;
    export type SQL = SQLExpression | SQLExpression[];
    export interface OrderSpec {
        by: SQL,
        direction: 'ASC' | 'DESC',
        nulls?: 'FIRST' | 'LAST',
    }
    export interface SelectOptions<C extends readonly Column[] > {
        order?: OrderSpec[];
        limit?: number,
        offset?: number,
        columns?: C,
    }
}

export namespace authors {
    export type Table = "authors";
    export interface Selectable {
        id: number;
        name: string;
        isLiving: boolean | null;
    }
    export interface Insertable {
        id?: number | DefaultType | SQLFragment;
        name: string | SQLFragment;
        isLiving?: boolean | null | DefaultType | SQLFragment;
    }
    export interface Updatable extends Partial<Insertable> { };
    export type Whereable = { [K in keyof Selectable]?: Selectable[K] | SQLFragment };
    export interface UpsertReturnable extends Selectable, UpsertAction { };
    export type Column = keyof Selectable;
    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
    export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;
    export type SQL = SQLExpression | SQLExpression[];
    export interface OrderSpec {
        by: SQL,
        direction: 'ASC' | 'DESC',
        nulls?: 'FIRST' | 'LAST',
    }
    export interface SelectOptions<C extends Column[], L extends SQLFragmentsMap> {
        order?: OrderSpec[];
        limit?: number,
        offset?: number,
        columns?: C,
        lateral?: L,
    }
    type BaseSelectReturnType<C extends Column[]> = C extends undefined ? Selectable : OnlyCols<C>;
    type WithLateralSelectReturnType<C extends Column[], L extends SQLFragmentsMap> =
        L extends undefined ? BaseSelectReturnType<C> : BaseSelectReturnType<C> & PromisedSQLFragmentReturnTypeMap<L>;
    export type FullSelectReturnType<C extends Column[], L extends SQLFragmentsMap, M extends SelectResultMode> =
        M extends SelectResultMode.Many ? WithLateralSelectReturnType<C, L>[] :
        M extends SelectResultMode.One ? WithLateralSelectReturnType<C, L> | undefined : number;
}

export namespace books {
    export type Table = "books";
    export interface Selectable {
        id: number;
        authorId: number;
        title: string | null;
        createdAt: Date;
        updatedAt: Date;
    }
    export interface Insertable {
        id?: number | DefaultType | SQLFragment;
        authorId: number | SQLFragment;
        title?: string | null | DefaultType | SQLFragment;
        createdAt?: Date | DefaultType | SQLFragment;
        updatedAt?: Date | DefaultType | SQLFragment;
    }
    export interface Updatable extends Partial<Insertable> { };
    export type Whereable = { [K in keyof Selectable]?: Selectable[K] | SQLFragment };
    export interface UpsertReturnable extends Selectable, UpsertAction { };
    export type Column = keyof Selectable;
    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
    export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;
    export type SQL = SQLExpression | SQLExpression[];
    export interface OrderSpec {
        by: SQL,
        direction: 'ASC' | 'DESC',
        nulls?: 'FIRST' | 'LAST',
    }
    export interface SelectOptions<C extends Column[], L extends SQLFragmentsMap> {
        order?: OrderSpec[];
        limit?: number,
        offset?: number,
        columns?: C,
        lateral?: L,
    }
    type BaseSelectReturnType<C extends Column[]> = C extends undefined ? Selectable : OnlyCols<C>;
    type WithLateralSelectReturnType<C extends Column[], L extends SQLFragmentsMap> =
        L extends undefined ? BaseSelectReturnType<C> : BaseSelectReturnType<C> & PromisedSQLFragmentReturnTypeMap<L>;
    export type FullSelectReturnType<C extends Column[], L extends SQLFragmentsMap, M extends SelectResultMode> =
        M extends SelectResultMode.Many ? WithLateralSelectReturnType<C, L>[] :
        M extends SelectResultMode.One ? WithLateralSelectReturnType<C, L> | undefined : number;
}

export namespace emailAuthentication {
    export type Table = "emailAuthentication";
    export interface Selectable {
        email: string;
        consecutiveFailedLogins: number;
        lastFailedLogin: Date | null;
    }
    export interface Insertable {
        email: string | SQLFragment;
        consecutiveFailedLogins?: number | DefaultType | SQLFragment;
        lastFailedLogin?: Date | null | DefaultType | SQLFragment;
    }
    export interface Updatable extends Partial<Insertable> { };
    export type Whereable = { [K in keyof Selectable]?: Selectable[K] | SQLFragment };
    export interface UpsertReturnable extends Selectable, UpsertAction { };
    export type Column = keyof Selectable;
    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
    export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;
    export type SQL = SQLExpression | SQLExpression[];
    export interface OrderSpec {
        by: SQL,
        direction: 'ASC' | 'DESC',
        nulls?: 'FIRST' | 'LAST',
    }
    export interface SelectOptions<C extends Column[], L extends SQLFragmentsMap> {
        order?: OrderSpec[];
        limit?: number,
        offset?: number,
        columns?: C,
        lateral?: L,
    }
    type BaseSelectReturnType<C extends Column[]> = C extends undefined ? Selectable : OnlyCols<C>;
    type WithLateralSelectReturnType<C extends Column[], L extends SQLFragmentsMap> =
        L extends undefined ? BaseSelectReturnType<C> : BaseSelectReturnType<C> & PromisedSQLFragmentReturnTypeMap<L>;
    export type FullSelectReturnType<C extends Column[], L extends SQLFragmentsMap, M extends SelectResultMode> =
        M extends SelectResultMode.Many ? WithLateralSelectReturnType<C, L>[] :
        M extends SelectResultMode.One ? WithLateralSelectReturnType<C, L> | undefined : number;
}

export namespace tags {
    export type Table = "tags";
    export interface Selectable {
        tag: string;
        bookId: number;
    }
    export interface Insertable {
        tag: string | SQLFragment;
        bookId: number | SQLFragment;
    }
    export interface Updatable extends Partial<Insertable> { };
    export type Whereable = { [K in keyof Selectable]?: Selectable[K] | SQLFragment };
    export interface UpsertReturnable extends Selectable, UpsertAction { };
    export type Column = keyof Selectable;
    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
    export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;
    export type SQL = SQLExpression | SQLExpression[];
    export interface OrderSpec {
        by: SQL,
        direction: 'ASC' | 'DESC',
        nulls?: 'FIRST' | 'LAST',
    }
    export interface SelectOptions<C extends readonly Column[] > {
        order?: OrderSpec[];
        limit?: number,
        offset?: number,
        columns?: C,
    }
}

export type Selectable = appleTransactions.Selectable | authors.Selectable | books.Selectable | emailAuthentication.Selectable | tags.Selectable;
export type Whereable = appleTransactions.Whereable | authors.Whereable | books.Whereable | emailAuthentication.Whereable | tags.Whereable;
export type Insertable = appleTransactions.Insertable | authors.Insertable | books.Insertable | emailAuthentication.Insertable | tags.Insertable;
export type Updatable = appleTransactions.Updatable | authors.Updatable | books.Updatable | emailAuthentication.Updatable | tags.Updatable;
export type Table = appleTransactions.Table | authors.Table | books.Table | emailAuthentication.Table | tags.Table;
export type Column = appleTransactions.Column | authors.Column | books.Column | emailAuthentication.Column | tags.Column;
export type AllTables = [appleTransactions.Table, authors.Table, books.Table, emailAuthentication.Table, tags.Table];

export interface InsertSignatures {
    (table: appleTransactions.Table, values: appleTransactions.Insertable): SQLFragment<appleTransactions.Selectable>;
    (table: appleTransactions.Table, values: appleTransactions.Insertable[]): SQLFragment<appleTransactions.Selectable[]>;
    (table: authors.Table, values: authors.Insertable): SQLFragment<authors.Selectable>;
    (table: authors.Table, values: authors.Insertable[]): SQLFragment<authors.Selectable[]>;
    (table: books.Table, values: books.Insertable): SQLFragment<books.Selectable>;
    (table: books.Table, values: books.Insertable[]): SQLFragment<books.Selectable[]>;
    (table: emailAuthentication.Table, values: emailAuthentication.Insertable): SQLFragment<emailAuthentication.Selectable>;
    (table: emailAuthentication.Table, values: emailAuthentication.Insertable[]): SQLFragment<emailAuthentication.Selectable[]>;
    (table: tags.Table, values: tags.Insertable): SQLFragment<tags.Selectable>;
    (table: tags.Table, values: tags.Insertable[]): SQLFragment<tags.Selectable[]>;
}
export interface UpsertSignatures {
    (table: appleTransactions.Table, values: appleTransactions.Insertable, uniqueCols: appleTransactions.Column | appleTransactions.Column[], noNullUpdateCols?: appleTransactions.Column | appleTransactions.Column[]): SQLFragment<appleTransactions.UpsertReturnable>;
    (table: appleTransactions.Table, values: appleTransactions.Insertable[], uniqueCols: appleTransactions.Column | appleTransactions.Column[], noNullUpdateCols?: appleTransactions.Column | appleTransactions.Column[]): SQLFragment<appleTransactions.UpsertReturnable[]>;
    (table: authors.Table, values: authors.Insertable, uniqueCols: authors.Column | authors.Column[], noNullUpdateCols?: authors.Column | authors.Column[]): SQLFragment<authors.UpsertReturnable>;
    (table: authors.Table, values: authors.Insertable[], uniqueCols: authors.Column | authors.Column[], noNullUpdateCols?: authors.Column | authors.Column[]): SQLFragment<authors.UpsertReturnable[]>;
    (table: books.Table, values: books.Insertable, uniqueCols: books.Column | books.Column[], noNullUpdateCols?: books.Column | books.Column[]): SQLFragment<books.UpsertReturnable>;
    (table: books.Table, values: books.Insertable[], uniqueCols: books.Column | books.Column[], noNullUpdateCols?: books.Column | books.Column[]): SQLFragment<books.UpsertReturnable[]>;
    (table: emailAuthentication.Table, values: emailAuthentication.Insertable, uniqueCols: emailAuthentication.Column | emailAuthentication.Column[], noNullUpdateCols?: emailAuthentication.Column | emailAuthentication.Column[]): SQLFragment<emailAuthentication.UpsertReturnable>;
    (table: emailAuthentication.Table, values: emailAuthentication.Insertable[], uniqueCols: emailAuthentication.Column | emailAuthentication.Column[], noNullUpdateCols?: emailAuthentication.Column | emailAuthentication.Column[]): SQLFragment<emailAuthentication.UpsertReturnable[]>;
    /* (client: Queryable, table: tags.Table, values: tags.Insertable, uniqueCols: tags.Column | tags.Column[], noNullUpdateCols?: tags.Column | tags.Column[]): Promise<tags.UpsertReturnable>;
    (client: Queryable, table: tags.Table, values: tags.Insertable[], uniqueCols: tags.Column | tags.Column[], noNullUpdateCols?: tags.Column | tags.Column[]): Promise<tags.UpsertReturnable[]>; */
}
export interface UpdateSignatures {
    //(client: Queryable, table: appleTransactions.Table, values: appleTransactions.Updatable, where: appleTransactions.Whereable): Promise<appleTransactions.Selectable[]>;
    (table: authors.Table, values: authors.Updatable, where: authors.Whereable | SQLFragment): SQLFragment<authors.Selectable[]>;
    (table: books.Table, values: books.Updatable, where: books.Whereable | SQLFragment): SQLFragment<books.Selectable[]>;
    (table: emailAuthentication.Table, values: emailAuthentication.Updatable, where: emailAuthentication.Whereable | SQLFragment): SQLFragment<emailAuthentication.Selectable[]>;
    // (client: Queryable, table: tags.Table, values: tags.Updatable, where: tags.Whereable): Promise<tags.Selectable[]>;
}
export interface DeleteSignatures {
    //(client: Queryable, table: appleTransactions.Table, where: appleTransactions.Whereable): Promise<appleTransactions.Selectable[]>;
    (table: authors.Table, where: authors.Whereable | SQLFragment): SQLFragment<authors.Selectable[]>;
    (table: books.Table, where: books.Whereable | SQLFragment): SQLFragment<books.Selectable[]>;
    //(client: Queryable, table: emailAuthentication.Table, where: emailAuthentication.Whereable): Promise<emailAuthentication.Selectable[]>;
    //(client: Queryable, table: tags.Table, where: tags.Whereable): Promise<tags.Selectable[]>;
}


export interface SelectSignatures {
    <C extends books.Column[], L extends SQLFragmentsMap, M extends SelectResultMode = SelectResultMode.Many>(
        table: books.Table,
        where: books.Whereable | SQLFragment | AllType,
        options?: books.SelectOptions<C, L>,
        mode?: M,
    ): SQLFragment<books.FullSelectReturnType<C, L, M>>; 
    
    <C extends authors.Column[], L extends SQLFragmentsMap, M extends SelectResultMode = SelectResultMode.Many>(
        table: authors.Table,
        where: authors.Whereable | SQLFragment | AllType,
        options?: authors.SelectOptions<C, L>,
        mode?: M,
    ): SQLFragment<authors.FullSelectReturnType<C, L, M>>;
    /*
    <T extends readonly appleTransactions.Column[]> (client: Queryable, table: appleTransactions.Table, where ?: appleTransactions.Whereable, options ?: appleTransactions.SelectOptions < T >, count ?: boolean): Promise<T extends undefined ? appleTransactions.Selectable[] : appleTransactions.OnlyCols<T>[]>;
<T extends readonly authors.Column[]>(client: Queryable, table: authors.Table, where ?: authors.Whereable, options ?: authors.SelectOptions < T >, count ?: boolean): Promise<T extends undefined ? authors.Selectable[] : authors.OnlyCols<T>[]>;
<T extends readonly books.Column[]>(client: Queryable, table: books.Table, where ?: books.Whereable, options ?: books.SelectOptions < T >, count ?: boolean): Promise<T extends undefined ? books.Selectable[] : books.OnlyCols<T>[]>;
<T extends readonly emailAuthentication.Column[]>(client: Queryable, table: emailAuthentication.Table, where ?: emailAuthentication.Whereable, options ?: emailAuthentication.SelectOptions < T >, count ?: boolean): Promise<T extends undefined ? emailAuthentication.Selectable[] : emailAuthentication.OnlyCols<T>[]>;
<T extends readonly tags.Column[]>(client: Queryable, table: tags.Table, where ?: tags.Whereable, options ?: tags.SelectOptions < T >, count ?: boolean): Promise<T extends undefined ? tags.Selectable[] : tags.OnlyCols<T>[]>;
*/
      }
export interface SelectOneSignatures {
    <C extends books.Column[], L extends SQLFragmentsMap>(
        table: books.Table,
        where: books.Whereable | SQLFragment | AllType,
        options?: books.SelectOptions<C, L>,
    ): SQLFragment<books.FullSelectReturnType<C, L, SelectResultMode.One>>; 
    
    <C extends authors.Column[], L extends SQLFragmentsMap>(
        table: authors.Table,
        where: authors.Whereable | SQLFragment | AllType,
        options?: authors.SelectOptions<C, L>,
    ): SQLFragment<authors.FullSelectReturnType<C, L, SelectResultMode.One>>;

    <C extends emailAuthentication.Column[], L extends SQLFragmentsMap>(
        table: emailAuthentication.Table,
        where: emailAuthentication.Whereable | SQLFragment | AllType,
        options?: emailAuthentication.SelectOptions<C, L>,
    ): SQLFragment<emailAuthentication.FullSelectReturnType<C, L, SelectResultMode.One>>;
    
    /*
    <T extends readonly appleTransactions.Column[]> (client: Queryable, table: appleTransactions.Table, where ?: appleTransactions.Whereable, options ?: appleTransactions.SelectOptions<T>): Promise<(T extends undefined ? appleTransactions.Selectable : appleTransactions.OnlyCols<T>) | undefined>;
<T extends readonly authors.Column[]>(client: Queryable, table: authors.Table, where ?: authors.Whereable, options ?: authors.SelectOptions<T>): Promise<(T extends undefined ? authors.Selectable : authors.OnlyCols<T>) | undefined>;
<T extends readonly books.Column[]>(client: Queryable, table: books.Table, where ?: books.Whereable, options ?: books.SelectOptions<T>): Promise<(T extends undefined ? books.Selectable : books.OnlyCols<T>) | undefined>;
<T extends readonly emailAuthentication.Column[]>(client: Queryable, table: emailAuthentication.Table, where ?: emailAuthentication.Whereable, options ?: emailAuthentication.SelectOptions<T>): Promise<(T extends undefined ? emailAuthentication.Selectable : emailAuthentication.OnlyCols<T>) | undefined>;
<T extends readonly tags.Column[]>(client: Queryable, table: tags.Table, where ?: tags.Whereable, options ?: tags.SelectOptions<T>): Promise<(T extends undefined ? tags.Selectable : tags.OnlyCols<T>) | undefined>;
*/
      }
export interface CountSignatures {
    (table: authors.Table, where: authors.Whereable | SQLFragment | AllType, options?: { columns: authors.Column[] }): SQLFragment<number>;
    (table: books.Table, where: books.Whereable | SQLFragment | AllType, options?: { columns: books.Column[] }): SQLFragment<number>;
/*
    (table: appleTransactions.Table, where?: appleTransactions.Whereable): Promise<number>;
    (table: emailAuthentication.Table, where?: emailAuthentication.Whereable): Promise<number>;
    (table: tags.Table, where?: tags.Whereable): Promise<number>;
    */
}
