/* tslint:disable */


/**
 * AUTO-GENERATED FILE @ 2019-11-04 16:12:30 - DO NOT EDIT!
 *
 * This file was automatically generated by schemats v.3.0.3
 * $ schemats generate -c postgres://localhost/mostly_ormless -t appleTransactions -t authors -t books -t emailAuthentication -t tags -s public
 *
 */


import {
    DefaultType,
    JSONValue,
    JSONArray,
    SQLFragment,
    GenericSQLExpression,
    SQLExpression,
    AllType,
    ColumnNames,
    ColumnValues,
    Queryable,
    UpsertAction,
    select,
} from "./core";

export type appleEnvironment = 'PROD' | 'Sandbox';
export namespace every {
    export type appleEnvironment = ['PROD', 'Sandbox'];
}

export namespace appleTransactions {
    export type Table = "appleTransactions";
    export interface Selectable {
        environment: appleEnvironment;
        originalTransactionId: string;
        accountId: number;
        latestReceiptData: string | null;
    }
    export interface Insertable {
        environment: appleEnvironment | SQLFragment;
        originalTransactionId: string | SQLFragment;
        accountId: number | SQLFragment;
        latestReceiptData?: string | null | DefaultType | SQLFragment;
    }
    export interface Updatable extends Partial<Insertable> { };
    export type Whereable = { [K in keyof Selectable]?: Selectable[K] | SQLFragment };
    export interface UpsertReturnable extends Selectable, UpsertAction { };
    export type Column = keyof Selectable;
    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
    export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;
    export type SQL = SQLExpression | SQLExpression[];
    export interface OrderSpec {
        by: SQL,
        direction: 'ASC' | 'DESC',
        nulls?: 'FIRST' | 'LAST',
    }
    export interface SelectOptions<C extends readonly Column[] > {
        order?: OrderSpec[];
        limit?: number,
        offset?: number,
        columns?: C,
    }
}

export namespace authors {
    export type Table = "authors";
    export interface Selectable {
        id: number;
        name: string;
        isLiving: boolean | null;
    }
    export interface Insertable {
        id?: number | DefaultType | SQLFragment;
        name: string | SQLFragment;
        isLiving?: boolean | null | DefaultType | SQLFragment;
    }
    export interface Updatable extends Partial<Insertable> { };
    export type Whereable = { [K in keyof Selectable]?: Selectable[K] | SQLFragment };
    export interface UpsertReturnable extends Selectable, UpsertAction { };
    export type Column = keyof Selectable;
    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
    export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;
    export type SQL = SQLExpression | SQLExpression[];
    export interface OrderSpec {
        by: SQL,
        direction: 'ASC' | 'DESC',
        nulls?: 'FIRST' | 'LAST',
    }
	export interface SelectOptions<C extends Column[], L extends undefined | { [k: string]: ReturnType<typeof select> }> {
        order?: OrderSpec[];
        limit?: number,
        offset?: number,
        columns?: C,
        lateral?: L,
        count?: boolean,  // for use by count
        one?: boolean,  // for use by selectOne
    }
}

export namespace books {
    export type Table = "books";
    export interface Selectable {
        id: number;
        authorId: number;
        title: string | null;
        createdAt: Date;
        updatedAt: Date;
    }
    export interface Insertable {
        id?: number | DefaultType | SQLFragment;
        authorId: number | SQLFragment;
        title?: string | null | DefaultType | SQLFragment;
        createdAt?: Date | DefaultType | SQLFragment;
        updatedAt?: Date | DefaultType | SQLFragment;
    }
    export interface Updatable extends Partial<Insertable> { };
    export type Whereable = { [K in keyof Selectable]?: Selectable[K] | SQLFragment };
    export interface UpsertReturnable extends Selectable, UpsertAction { };
    export type Column = keyof Selectable;
    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
    export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;
    export type SQL = SQLExpression | SQLExpression[];
    export interface OrderSpec {
        by: SQL,
        direction: 'ASC' | 'DESC',
        nulls?: 'FIRST' | 'LAST',
    }
    export interface SelectOptions<C extends Column[], L extends undefined | { [k: string]: ReturnType<typeof select> }> {
        order?: OrderSpec[];
        limit?: number,
        offset?: number,
        columns?: C,
        lateral?: L,
        count?: boolean,  // for use by count
        one?: boolean,  // for use by selectOne
    }
}

export namespace emailAuthentication {
    export type Table = "emailAuthentication";
    export interface Selectable {
        email: string;
        consecutiveFailedLogins: number;
        lastFailedLogin: Date | null;
    }
    export interface Insertable {
        email: string | SQLFragment;
        consecutiveFailedLogins?: number | DefaultType | SQLFragment;
        lastFailedLogin?: Date | null | DefaultType | SQLFragment;
    }
    export interface Updatable extends Partial<Insertable> { };
    export type Whereable = { [K in keyof Selectable]?: Selectable[K] | SQLFragment };
    export interface UpsertReturnable extends Selectable, UpsertAction { };
    export type Column = keyof Selectable;
    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
    export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;
    export type SQL = SQLExpression | SQLExpression[];
    export interface OrderSpec {
        by: SQL,
        direction: 'ASC' | 'DESC',
        nulls?: 'FIRST' | 'LAST',
    }
    export interface SelectOptions<C extends readonly Column[] > {
        order?: OrderSpec[];
        limit?: number,
        offset?: number,
        columns?: C,
    }
}

export namespace tags {
    export type Table = "tags";
    export interface Selectable {
        tag: string;
        bookId: number;
    }
    export interface Insertable {
        tag: string | SQLFragment;
        bookId: number | SQLFragment;
    }
    export interface Updatable extends Partial<Insertable> { };
    export type Whereable = { [K in keyof Selectable]?: Selectable[K] | SQLFragment };
    export interface UpsertReturnable extends Selectable, UpsertAction { };
    export type Column = keyof Selectable;
    export type OnlyCols<T extends readonly Column[]> = Pick<Selectable, T[number]>;
    export type SQLExpression = GenericSQLExpression | Table | Whereable | Column | ColumnNames<Updatable | (keyof Updatable)[]> | ColumnValues<Updatable>;
    export type SQL = SQLExpression | SQLExpression[];
    export interface OrderSpec {
        by: SQL,
        direction: 'ASC' | 'DESC',
        nulls?: 'FIRST' | 'LAST',
    }
    export interface SelectOptions<C extends readonly Column[] > {
        order?: OrderSpec[];
        limit?: number,
        offset?: number,
        columns?: C,
    }
}

export type Selectable = appleTransactions.Selectable | authors.Selectable | books.Selectable | emailAuthentication.Selectable | tags.Selectable;
export type Whereable = appleTransactions.Whereable | authors.Whereable | books.Whereable | emailAuthentication.Whereable | tags.Whereable;
export type Insertable = appleTransactions.Insertable | authors.Insertable | books.Insertable | emailAuthentication.Insertable | tags.Insertable;
export type Updatable = appleTransactions.Updatable | authors.Updatable | books.Updatable | emailAuthentication.Updatable | tags.Updatable;
export type Table = appleTransactions.Table | authors.Table | books.Table | emailAuthentication.Table | tags.Table;
export type Column = appleTransactions.Column | authors.Column | books.Column | emailAuthentication.Column | tags.Column;
export type AllTables = [appleTransactions.Table, authors.Table, books.Table, emailAuthentication.Table, tags.Table];

export interface InsertSignatures {
    (client: Queryable, table: appleTransactions.Table, values: appleTransactions.Insertable): Promise<appleTransactions.Selectable>;
    (client: Queryable, table: appleTransactions.Table, values: appleTransactions.Insertable[]): Promise<appleTransactions.Selectable[]>;
    (client: Queryable, table: authors.Table, values: authors.Insertable): Promise<authors.Selectable>;
    (client: Queryable, table: authors.Table, values: authors.Insertable[]): Promise<authors.Selectable[]>;
    (client: Queryable, table: books.Table, values: books.Insertable): Promise<books.Selectable>;
    (client: Queryable, table: books.Table, values: books.Insertable[]): Promise<books.Selectable[]>;
    (client: Queryable, table: emailAuthentication.Table, values: emailAuthentication.Insertable): Promise<emailAuthentication.Selectable>;
    (client: Queryable, table: emailAuthentication.Table, values: emailAuthentication.Insertable[]): Promise<emailAuthentication.Selectable[]>;
    (client: Queryable, table: tags.Table, values: tags.Insertable): Promise<tags.Selectable>;
    (client: Queryable, table: tags.Table, values: tags.Insertable[]): Promise<tags.Selectable[]>;
}
export interface UpsertSignatures {
    (client: Queryable, table: appleTransactions.Table, values: appleTransactions.Insertable, uniqueCols: appleTransactions.Column | appleTransactions.Column[], noNullUpdateCols?: appleTransactions.Column | appleTransactions.Column[]): Promise<appleTransactions.UpsertReturnable>;
    (client: Queryable, table: appleTransactions.Table, values: appleTransactions.Insertable[], uniqueCols: appleTransactions.Column | appleTransactions.Column[], noNullUpdateCols?: appleTransactions.Column | appleTransactions.Column[]): Promise<appleTransactions.UpsertReturnable[]>;
    (client: Queryable, table: authors.Table, values: authors.Insertable, uniqueCols: authors.Column | authors.Column[], noNullUpdateCols?: authors.Column | authors.Column[]): Promise<authors.UpsertReturnable>;
    (client: Queryable, table: authors.Table, values: authors.Insertable[], uniqueCols: authors.Column | authors.Column[], noNullUpdateCols?: authors.Column | authors.Column[]): Promise<authors.UpsertReturnable[]>;
    (client: Queryable, table: books.Table, values: books.Insertable, uniqueCols: books.Column | books.Column[], noNullUpdateCols?: books.Column | books.Column[]): Promise<books.UpsertReturnable>;
    (client: Queryable, table: books.Table, values: books.Insertable[], uniqueCols: books.Column | books.Column[], noNullUpdateCols?: books.Column | books.Column[]): Promise<books.UpsertReturnable[]>;
    (client: Queryable, table: emailAuthentication.Table, values: emailAuthentication.Insertable, uniqueCols: emailAuthentication.Column | emailAuthentication.Column[], noNullUpdateCols?: emailAuthentication.Column | emailAuthentication.Column[]): Promise<emailAuthentication.UpsertReturnable>;
    (client: Queryable, table: emailAuthentication.Table, values: emailAuthentication.Insertable[], uniqueCols: emailAuthentication.Column | emailAuthentication.Column[], noNullUpdateCols?: emailAuthentication.Column | emailAuthentication.Column[]): Promise<emailAuthentication.UpsertReturnable[]>;
    (client: Queryable, table: tags.Table, values: tags.Insertable, uniqueCols: tags.Column | tags.Column[], noNullUpdateCols?: tags.Column | tags.Column[]): Promise<tags.UpsertReturnable>;
    (client: Queryable, table: tags.Table, values: tags.Insertable[], uniqueCols: tags.Column | tags.Column[], noNullUpdateCols?: tags.Column | tags.Column[]): Promise<tags.UpsertReturnable[]>;
}
export interface UpdateSignatures {
    (client: Queryable, table: appleTransactions.Table, values: appleTransactions.Updatable, where: appleTransactions.Whereable): Promise<appleTransactions.Selectable[]>;
    (client: Queryable, table: authors.Table, values: authors.Updatable, where: authors.Whereable): Promise<authors.Selectable[]>;
    (client: Queryable, table: books.Table, values: books.Updatable, where: books.Whereable): Promise<books.Selectable[]>;
    (client: Queryable, table: emailAuthentication.Table, values: emailAuthentication.Updatable, where: emailAuthentication.Whereable): Promise<emailAuthentication.Selectable[]>;
    (client: Queryable, table: tags.Table, values: tags.Updatable, where: tags.Whereable): Promise<tags.Selectable[]>;
}
export interface DeleteSignatures {
    (client: Queryable, table: appleTransactions.Table, where: appleTransactions.Whereable): Promise<appleTransactions.Selectable[]>;
    (client: Queryable, table: authors.Table, where: authors.Whereable): Promise<authors.Selectable[]>;
    (client: Queryable, table: books.Table, where: books.Whereable): Promise<books.Selectable[]>;
    (client: Queryable, table: emailAuthentication.Table, where: emailAuthentication.Whereable): Promise<emailAuthentication.Selectable[]>;
    (client: Queryable, table: tags.Table, where: tags.Whereable): Promise<tags.Selectable[]>;
}


type PromisedType<P> = P extends Promise<infer U> ? U : never;
	


export interface SelectSignatures {
	<C extends books.Column[], L extends { [k: string]: { run: (...args: any) => any } }>(
		table: books.Table, where: books.Whereable | SQLFragment | AllType, options?: books.SelectOptions<C, L>
	): SQLFragment<((C extends undefined ? books.Selectable : books.OnlyCols<C>) &
		(L extends undefined ? {} : { [K in keyof L]: PromisedType<ReturnType<L[K]['run']>> }))[]>; 
    
	<C extends authors.Column[], L extends { [k: string]: { run: (...args: any) => any } }>(
		table: authors.Table, where: authors.Whereable | SQLFragment | AllType, options?: authors.SelectOptions<C, L>
	): SQLFragment<((C extends undefined ? authors.Selectable : authors.OnlyCols<C>) &
		(L extends undefined ? {} : { [K in keyof L]: PromisedType<ReturnType<L[K]['run']>> }))[]>;
    /*
    <T extends readonly appleTransactions.Column[]> (client: Queryable, table: appleTransactions.Table, where ?: appleTransactions.Whereable, options ?: appleTransactions.SelectOptions < T >, count ?: boolean): Promise<T extends undefined ? appleTransactions.Selectable[] : appleTransactions.OnlyCols<T>[]>;
<T extends readonly authors.Column[]>(client: Queryable, table: authors.Table, where ?: authors.Whereable, options ?: authors.SelectOptions < T >, count ?: boolean): Promise<T extends undefined ? authors.Selectable[] : authors.OnlyCols<T>[]>;
<T extends readonly books.Column[]>(client: Queryable, table: books.Table, where ?: books.Whereable, options ?: books.SelectOptions < T >, count ?: boolean): Promise<T extends undefined ? books.Selectable[] : books.OnlyCols<T>[]>;
<T extends readonly emailAuthentication.Column[]>(client: Queryable, table: emailAuthentication.Table, where ?: emailAuthentication.Whereable, options ?: emailAuthentication.SelectOptions < T >, count ?: boolean): Promise<T extends undefined ? emailAuthentication.Selectable[] : emailAuthentication.OnlyCols<T>[]>;
<T extends readonly tags.Column[]>(client: Queryable, table: tags.Table, where ?: tags.Whereable, options ?: tags.SelectOptions < T >, count ?: boolean): Promise<T extends undefined ? tags.Selectable[] : tags.OnlyCols<T>[]>;
*/
      }
export interface SelectOneSignatures {
    <T extends readonly appleTransactions.Column[]> (client: Queryable, table: appleTransactions.Table, where ?: appleTransactions.Whereable, options ?: appleTransactions.SelectOptions<T>): Promise<(T extends undefined ? appleTransactions.Selectable : appleTransactions.OnlyCols<T>) | undefined>;
<T extends readonly authors.Column[]>(client: Queryable, table: authors.Table, where ?: authors.Whereable, options ?: authors.SelectOptions<T>): Promise<(T extends undefined ? authors.Selectable : authors.OnlyCols<T>) | undefined>;
<T extends readonly books.Column[]>(client: Queryable, table: books.Table, where ?: books.Whereable, options ?: books.SelectOptions<T>): Promise<(T extends undefined ? books.Selectable : books.OnlyCols<T>) | undefined>;
<T extends readonly emailAuthentication.Column[]>(client: Queryable, table: emailAuthentication.Table, where ?: emailAuthentication.Whereable, options ?: emailAuthentication.SelectOptions<T>): Promise<(T extends undefined ? emailAuthentication.Selectable : emailAuthentication.OnlyCols<T>) | undefined>;
<T extends readonly tags.Column[]>(client: Queryable, table: tags.Table, where ?: tags.Whereable, options ?: tags.SelectOptions<T>): Promise<(T extends undefined ? tags.Selectable : tags.OnlyCols<T>) | undefined>;
      }
export interface CountSignatures {
    (client: Queryable, table: appleTransactions.Table, where?: appleTransactions.Whereable): Promise<number>;
    (client: Queryable, table: authors.Table, where?: authors.Whereable): Promise<number>;
    (client: Queryable, table: books.Table, where?: books.Whereable): Promise<number>;
    (client: Queryable, table: emailAuthentication.Table, where?: emailAuthentication.Whereable): Promise<number>;
    (client: Queryable, table: tags.Table, where?: tags.Whereable): Promise<number>;
}
